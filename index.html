<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dialogue Timer</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* Custom styling for the loading spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: none;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Custom styling for the range slider (simulating a sleek control) */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #4b5563; /* Gray-600 */
            border-radius: 4px;
        }
        /* Thumb styling */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6; /* Blue-500 */
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: background 0.15s ease-in-out;
            border: 3px solid #0d1117;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            background: #2563eb; /* Blue-600 */
        }
        
        /* --- Tooltip/Hint Styles --- */
        /* Styling for the help icon and tooltip */
        .help-icon {
            position: absolute; /* Set absolute to stack it cleanly */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            color: #fcd34d; /* Pale yellow color */
            font-weight: 700; /* Bold */
            transition: opacity 0.3s, transform 0.3s; /* Added transition for smooth vanish */
            line-height: 1; 
            display: none; 
            font-size: 1.25rem; /* text-xl */
        }
        .help-icon:hover {
            color: #fff;
        }

        /* Container for the icon and tooltip. This is the new hover target. */
        .help-container {
            position: relative;
            display: inline-flex;
            width: 20px; /* Define width/height for the container */
            height: 20px;
            justify-content: center;
            align-items: center;
        }

        /* NEW RULE: Make icon vanish and scale down on container hover */
        .help-container:hover .help-icon {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }

        .hints-active .help-icon {
            display: block; /* Show when hints are active on main wrapper */
        }

        .help-tooltip {
            position: absolute;
            top: calc(100% + 4px); /* PUSHED DOWN 4px to clear icon */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000; 
            width: 280px;
            padding: 0.75rem;
            background-color: #1f2937; /* Gray-800 */
            border: 1px solid #4b5563; /* Gray-600 */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, visibility 0.3s;
            visibility: hidden;
            font-size: 0.75rem; /* text-xs */
            line-height: 1.3;
            color: #e5e7eb; /* Gray-200 */
        }
        
        /* NEW RULE: Show the tooltip on container hover */
        .help-container:hover .help-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Arrow styles remain the same, ensuring they point correctly */
        .help-tooltip::before {
            content: '';
            position: absolute;
            bottom: calc(100% - 4px); 
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #4b5563 transparent; 
        }
        .help-tooltip::after {
            content: '';
            position: absolute;
            bottom: calc(100% - 4px); 
            left: 50%;
            transform: translateX(-50%);
            border-width: 4px;
            border-style: solid;
            border-color: transparent transparent #1f2937 transparent; 
            margin-bottom: 1px;
        }
    </style>
</head>
<body>
    <!-- Main container where 'hints-active' class is toggled -->
    <div class="w-full max-w-lg p-6 md:p-10 bg-gray-800 rounded-xl shadow-2xl border border-gray-700">
        
        <!-- Header with Title and Hints Toggle Button -->
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-3xl font-extrabold text-white flex items-center">
                Dialogue Timer
                <!-- HINT 0: App Title Description - Wrapped in help-container -->
                <div class="help-container ml-2">
                    <span class="help-icon text-xl">?</span>
                    <div class="help-tooltip w-80 translate-x-[-70%] md:translate-x-[-150px]">
                        This is a tool to help determine if a bit of script is too wordy. By entering the dialogue and selecting a target timeframe, you can see how well the two match. Or don't.
                    </div>
                </div>
            </h1>
            
            <!-- Hints Toggle Button: Initial styling is gray, changed by JS when active -->
            <button onclick="toggleHints()" id="hintsToggleButton" class="px-3 py-1 text-sm bg-gray-700 text-gray-300 rounded-full hover:bg-gray-600 transition duration-150">
                Hints
            </button>
        </div>
        
        <!-- Target Time Control (Knob/Slider simulation) -->
        <div class="mb-6 p-4 bg-gray-900 rounded-lg border border-gray-700 shadow-inner">
            <label for="targetTimeInput" class="block text-sm font-medium text-gray-300 mb-1 text-center flex justify-center items-center">
                Adjust the slider to your desired target timeframe
                <!-- HINT 1: Target Time - Wrapped in help-container -->
                <div class="help-container ml-2">
                    <span class="help-icon text-lg">?</span>
                    <div class="help-tooltip w-64 -translate-x-1/2">
                        This slider does not affect play speed in any way. It simply sets a "time budget" that the app can use to evaluate how well the spoken words fit into your desired timeframe.
                    </div>
                </div>
            </label>
            <p class="text-xs font-medium text-gray-500 mb-3 text-center">
                or use shortcuts below to snap to predefined lengths.
            </p>
            
            <div class="text-center mb-4">
                <span id="targetTimeDisplay" class="text-blue-400 text-4xl font-mono font-extrabold tracking-tight">7.00</span>
                <span class="text-gray-400 text-xl font-bold">seconds</span>
            </div>
            <input type="range" id="targetTimeInput" min="1.0" max="60.0" step="0.05" value="7.00"
                    class="w-full"
                    oninput="updateTargetTimeDisplay(this.value)"
                    onchange="clearResults()">
            <div class="flex justify-between text-xs text-gray-500 mt-2">
                <span>1.0s</span>
                <span>60.0s</span>
            </div>
            
            <!-- Snap Buttons - NOW FIVE BUTTONS using justify-between -->
            <div class="flex justify-between mt-4 pt-4 border-t border-gray-700">
                <label class="inline-flex items-center text-gray-300">
                    <input type="radio" name="snapTime" value="7.00" onchange="snapToTime(this.value)" class="form-radio text-blue-500 h-4 w-4 bg-gray-700 border-gray-600" checked>
                    <span class="ml-2 text-sm font-medium">7s</span>
                </label>
                <!-- NEW 12s SNAP -->
                <label class="inline-flex items-center text-gray-300">
                    <input type="radio" name="snapTime" value="12.00" onchange="snapToTime(this.value)" class="form-radio text-blue-500 h-4 w-4 bg-gray-700 border-gray-600">
                    <span class="ml-2 text-sm font-medium">12s</span>
                </label>
                <!-- NEW 15s SNAP -->
                <label class="inline-flex items-center text-gray-300">
                    <input type="radio" name="snapTime" value="15.00" onchange="snapToTime(this.value)" class="form-radio text-blue-500 h-4 w-4 bg-gray-700 border-gray-600">
                    <span class="ml-2 text-sm font-medium">15s</span>
                </label>
                <label class="inline-flex items-center text-gray-300">
                    <input type="radio" name="snapTime" value="30.00" onchange="snapToTime(this.value)" class="form-radio text-blue-500 h-4 w-4 bg-gray-700 border-gray-600">
                    <span class="ml-2 text-sm font-medium">30s</span>
                </label>
                <label class="inline-flex items-center text-gray-300">
                    <input type="radio" name="snapTime" value="45.00" onchange="snapToTime(this.value)" class="form-radio text-blue-500 h-4 w-4 bg-gray-700 border-gray-600">
                    <span class="ml-2 text-sm font-medium">45s</span>
                </label>
            </div>
        </div>
        <!-- /Target Time Control -->


        <!-- Input Area -->
        <div class="mb-6">
            <label for="dialogueInput" class="block text-sm font-medium text-gray-300 mb-2">Enter Dialogue Script (1-200 words):</label>
            <textarea id="dialogueInput" rows="4"
                    class="w-full p-3 bg-gray-700 text-white border border-gray-600 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                    placeholder="Type or paste your dialogue here..."
                    onkeyup="updateWordCount(this)"
                    onchange="clearResults()"
            ></textarea>
            <p id="wordCount" class="text-xs text-gray-500 mt-1 text-right">0 words</p>
        </div>

        <!-- Submit Button -->
        <button onclick="calculateTiming()"
                id="submitButton"
                class="w-full px-4 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50 transition duration-150 transform hover:scale-[1.01] shadow-lg disabled:bg-gray-500 disabled:cursor-not-allowed"
                disabled>
            Calculate Spoken Time
        </button>

        <!-- Result Section -->
        <div id="results" class="mt-8 p-6 bg-gray-700 rounded-xl transition duration-300 hidden">
            <div class="flex items-start space-x-4">
                <!-- Status Light -->
                <div id="statusLight" class="w-6 h-6 rounded-full shadow-lg transition-colors duration-300 mt-1"></div>
                
                <!-- Result Message and Pacing Info (main output area) -->
                <div class="flex-grow relative">
                    <p id="resultMessage" class="text-xl font-bold text-white inline"></p>
                    <!-- HINT 2: Estimate & Status - Wrapped in help-container -->
                    <div class="help-container align-top ml-2 inline-block">
                        <span class="help-icon text-lg">?</span>
                        <div class="help-tooltip w-64 translate-x-[-15%]">
                            <p class="mb-2">This is a <span class="font-bold">rough estimate</span> based on a standard comfortable pacing rate (130 WPM). Actual time may vary.</p>
                            <strong class="text-green-400">Green:</strong> Time met.<br>
                            <strong class="text-yellow-400">Yellow:</strong> Rushed, but acceptable (within a small buffer).<br>
                            <strong class="text-red-400">Red:</strong> Time significantly exceeded. Probable failure.
                        </div>
                    </div>
                    <p id="pacingInfo" class="text-sm text-gray-400 mt-1"></p>
                </div>
            </div>
            
            <div id="additionalInfo" class="mt-4 pt-4 border-t border-gray-600 text-sm text-gray-300">
                <p>Word Count: <span id="finalWordCount" class="font-bold"></span></p>
                <!-- Display for actual measured duration (always based on 1.0x playback rate) -->
                <p id="actualDurationDisplay" class="mt-2 hidden">Actual 1.0x Duration: <span class="font-bold text-yellow-300"></span></p>
            </div>
            
            <!-- TTS Section -->
            <div class="mt-4 pt-4 border-t border-gray-600">
                <label for="voiceSelect" class="block text-sm font-medium text-gray-300 mb-2">Configure and Play (Fixed Rates):</label>
                <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3 items-center mb-3">
                    
                    <!-- Voice Select - ADDED onchange="clearResults()" -->
                    <select id="voiceSelect"
                            onchange="clearResults()"
                            class="w-full sm:w-1/2 p-2 bg-gray-900 text-white border border-gray-600 rounded-lg focus:ring-green-500 focus:border-green-500">
                        <!-- Voices updated per user request -->
                        <option value="Schedar" selected>Male (Even)</option>
                        <option value="Leda">Female (Youthful)</option>
                        <option value="Kore">Male (Firm)</option>
                        <option value="Puck">Female (Upbeat)</option>
                    </select>

                    <!-- Prepare Button (Replaced old Listen Now) -->
                    <button onclick="prepareAudio()"
                            id="prepareButton"
                            disabled
                            class="w-full sm:w-1/2 flex justify-center items-center px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-500 focus:ring-opacity-50 transition duration-150 disabled:bg-gray-500 disabled:cursor-not-allowed">
                        <span id="prepareText">Prepare Audio</span>
                        <div id="prepareSpinner" class="spinner ml-2"></div>
                    </button>
                </div>

                <!-- Play Button Container (Grid layout for two buttons) -->
                <div id="playButtonContainer" class="mt-3 grid grid-cols-2 gap-3 hidden">
                    <!-- Normal Playback Button (1.0x) -->
                    <button onclick="playNormalAudio()"
                            id="playNormalButton"
                            disabled
                            class="px-4 py-3 bg-gray-500 text-white font-semibold rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                        <!-- Text set by JavaScript to include timeCP -->
                    </button>
                    <!-- Conformed Playback Button (Adjusted Rate) -->
                    <button onclick="playConformedAudio()"
                            id="playConformedButton"
                            disabled
                            class="px-4 py-3 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                        <!-- Text set by JavaScript to include currentPlaybackDuration -->
                    </button>
                </div>

                <!-- Dynamic Speed Control -->
                <div id="dynamicSpeedControl" class="mt-6 pt-4 border-t border-gray-600 hidden">
                    <div class="flex items-center mb-2">
                        <label class="block text-sm font-medium text-gray-300">Adjust Playback Speed (Dynamic)</label>
                        <!-- HINT 3: Dynamic Speed Control - Wrapped in help-container -->
                        <div class="help-container ml-2">
                            <span class="help-icon text-lg">?</span>
                            <div class="help-tooltip w-64 -translate-x-1/4">
                                By adjusting the playback speed, this slider allows you to force the audio to conform to a specific timeframe. Use it to hear how rushed your dialogue may sound when spoken.
                            </div>
                        </div>
                    </div>
                    
                    <!-- Rate and Duration Display -->
                    <div class="text-center mb-3 p-3 bg-gray-800 rounded-lg border border-gray-700">
                        <p class="text-xl font-mono font-bold text-yellow-300">
                            Rate: <span id="currentDynamicRate">1.00</span>x
                        </p>
                        <p class="text-sm text-gray-400">
                            Duration: <span id="currentDynamicDuration">7.00</span>s
                        </p>
                    </div>

                    <!-- Slider -->
                    <input type="range" id="dynamicRateInput" min="0.5" max="2.0" step="0.01" value="1.00"
                            class="w-full"
                            oninput="updateDynamicRateDisplay(this.value)">

                    <div class="flex justify-between text-xs text-gray-500 mt-2 mb-4">
                        <span>0.5x (Slower)</span>
                        <span>2.0x (Faster)</span>
                    </div>

                    <!-- Custom Play Button -->
                    <button onclick="playCustomRateAudio()"
                            id="playCustomButton"
                            disabled
                            class="w-full px-4 py-3 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 focus:outline-none focus:ring-4 focus:ring-red-500 focus:ring-opacity-50 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
                        Play at Custom Rate
                    </button>
                </div>
                
                <!-- Custom Time Display (Replaces misleading native player time) -->
                <div id="customTimerDisplay" class="mt-4 text-center text-4xl font-mono font-extrabold text-blue-400 hidden">
                    <span id="currentTime">7.00</span>s
                </div>

                <p id="ttsPacingNote" class="text-xs text-gray-500 mt-3">Pacing: Normal (1.00x)</p>
                <!-- Audio Player (Controls attribute removed for custom timer) -->
                <audio id="audioPlayer" class="mt-3 w-full hidden"></audio>
            </div>
        </div>

        <!-- Modal/Error Box (To replace alert()) -->
        <div id="modalBox" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center p-4 z-50">
            <div class="bg-red-800 p-6 rounded-lg shadow-xl max-w-sm w-full border border-red-700">
                <p id="modalText" class="text-white font-semibold"></p>
                <button onclick="closeModal()" class="mt-4 w-full bg-red-600 hover:bg-red-700 text-white py-2 rounded-lg transition">
                    OK
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- Configuration Constants ---
        const CP_WPM = 130; // Comfortable Pacing Words Per Minute (standard reading/speaking rate)
        const MAX_WORDS = 200; 
        const ACCEPTABLE_VARIANCE = 0.2; // 20% margin for Yellow status
        
        // --- TTS API Configuration ---
        const API_MODEL = "gemini-2.5-flash-preview-tts";
        const API_KEY = ""; // Provided by the Canvas environment
        const API_URL_BASE = "https://generativelanguage.googleapis.com/v1beta/models/";
        const API_FULL_URL = `${API_URL_BASE}${API_MODEL}:generateContent?key=${API_KEY}`;
        const MAX_RETRIES = 5;

        // --- Global State ---
        let timeCP = 0.0; // Stores Comfortable Pacing duration (Actual 1.0x rate duration) - updated after audio loads
        let requiredPlaybackRate = 1.0; 
        let targetTime = 7.00; // The target time from the slider
        let timerInterval = null; // Variable for the custom countdown timer
        let currentTimerDuration = 7.00; // The duration the current timer is counting down from
        let currentPlayingMode = null; // Tracks which mode is currently playing: 'normal', 'conformed', or 'custom'
        
        // Get DOM elements
        const mainContainer = document.querySelector('.w-full.max-w-lg');
        const inputElement = document.getElementById('dialogueInput');
        const wordCountElement = document.getElementById('wordCount');
        const submitButton = document.getElementById('submitButton');
        const resultsBox = document.getElementById('results');
        const statusLight = document.getElementById('statusLight');
        const resultMessage = document.getElementById('resultMessage');
        const pacingInfo = document.getElementById('pacingInfo');
        const finalWordCount = document.getElementById('finalWordCount');
        const modalBox = document.getElementById('modalBox');
        const modalText = document.getElementById('modalText');
        const voiceSelect = document.getElementById('voiceSelect');
        const audioPlayer = document.getElementById('audioPlayer');
        
        // New/Updated DOM Elements
        const targetTimeInput = document.getElementById('targetTimeInput');
        const targetTimeDisplay = document.getElementById('targetTimeDisplay');
        const prepareButton = document.getElementById('prepareButton');
        const prepareText = document.getElementById('prepareText');
        const prepareSpinner = document.getElementById('prepareSpinner');
        const playButtonContainer = document.getElementById('playButtonContainer');
        const playNormalButton = document.getElementById('playNormalButton');
        const playConformedButton = document.getElementById('playConformedButton');
        const ttsPacingNote = document.getElementById('ttsPacingNote');
        const actualDurationDisplay = document.getElementById('actualDurationDisplay');
        const actualDurationSpan = actualDurationDisplay.querySelector('span');
        const customTimerDisplay = document.getElementById('customTimerDisplay');
        const currentTimeElement = document.getElementById('currentTime');
        const hintsToggleButton = document.getElementById('hintsToggleButton');
        
        // Dynamic Speed Control Elements
        const dynamicSpeedControl = document.getElementById('dynamicSpeedControl');
        const dynamicRateInput = document.getElementById('dynamicRateInput');
        const currentDynamicRate = document.getElementById('currentDynamicRate');
        const currentDynamicDuration = document.getElementById('currentDynamicDuration');
        const playCustomButton = document.getElementById('playCustomButton');


        // --- Utility Functions (Modal, Word Count, Target Display) ---

        /**
         * Toggles the 'hints-active' class on the main container to show/hide tooltips,
         * and updates the button styling.
         */
        function toggleHints() {
            mainContainer.classList.toggle('hints-active');
            
            const isActive = mainContainer.classList.contains('hints-active');

            if (isActive) {
                // Apply active (yellow, bold) styling
                hintsToggleButton.classList.remove('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
                hintsToggleButton.classList.add('bg-yellow-500', 'text-gray-900', 'font-bold', 'hover:bg-yellow-400');
            } else {
                // Apply inactive (gray) styling
                hintsToggleButton.classList.remove('bg-yellow-500', 'text-gray-900', 'font-bold', 'hover:bg-yellow-400');
                hintsToggleButton.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
            }
        }

        function showModal(message) {
            modalText.textContent = message;
            modalBox.classList.remove('hidden');
            modalBox.classList.add('flex');
        }

        function closeModal() {
            modalBox.classList.remove('flex');
            modalBox.classList.add('hidden');
        }

        function countWords(text) {
            if (!text) return 0;
            const words = text.trim().split(/\s+/).filter(word => word.length > 0); 
            return words.length;
        }

        function updateWordCount(element) {
            const text = element.value;
            const count = countWords(text);
            
            wordCountElement.textContent = count + ' words';
            
            if (count > MAX_WORDS) {
                wordCountElement.classList.remove('text-gray-500');
                wordCountElement.classList.add('text-red-500', 'font-bold');
            } else {
                wordCountElement.classList.remove('text-red-500', 'font-bold');
                wordCountElement.classList.add('text-gray-500');
            }
            
            // Re-check submit button and clear results immediately on key up/change
            clearResults();
            if (count > 0 && count <= MAX_WORDS) {
                submitButton.disabled = false;
                prepareButton.disabled = false;
            } else {
                submitButton.disabled = true;
                prepareButton.disabled = true;
            }
        }
        
        function updateTargetTimeDisplay(value) {
            // Update the prominent display with the slider's current value
            targetTime = parseFloat(value);
            targetTimeDisplay.textContent = targetTime.toFixed(2);
            clearResults();
        }
        
        /**
         * Clears all results, resets the UI.
         */
        function clearResults() {
             // Stop audio if playing and clear timer
             audioPlayer.pause();
             audioPlayer.currentTime = 0;
             stopCountdown();
             
             // Reset UI states
             resultsBox.classList.add('hidden');
             voiceSelect.disabled = false;
             playButtonContainer.classList.add('hidden'); 
             playNormalButton.disabled = true;
             playConformedButton.disabled = true;
             audioPlayer.classList.add('hidden');
             customTimerDisplay.classList.add('hidden'); 
             dynamicSpeedControl.classList.add('hidden');
             playCustomButton.disabled = true;
             
             ttsPacingNote.textContent = 'Pacing: Normal (1.00x)';
             actualDurationDisplay.classList.add('hidden');
             
             // Reset global state
             requiredPlaybackRate = 1.0; 
             timeCP = 0.0;
             currentPlayingMode = null;
             
             // Re-enable/reset submit and prepare buttons based on current input validity
             const wordCount = countWords(inputElement.value);
             if (wordCount > 0 && wordCount <= MAX_WORDS) {
                 submitButton.disabled = false;
                 prepareButton.disabled = false;
                 prepareText.textContent = 'Prepare Audio';
                 prepareSpinner.style.display = 'none';
             } else {
                 submitButton.disabled = true;
                 prepareButton.disabled = true;
                 prepareText.textContent = 'Prepare Audio';
                 prepareSpinner.style.display = 'none';
             }
             updateButtonLabels(null);
        }

        /**
         * Snaps the time slider to a pre-defined value.
         * @param {string} seconds - The time value as a string (e.g., "7.00").
         */
        function snapToTime(seconds) {
            const time = parseFloat(seconds);
            targetTimeInput.value = time.toFixed(2);
            updateTargetTimeDisplay(time.toFixed(2));
            clearResults();
        }
        
        // --- Custom Timer Logic ---
        
        function stopCountdown() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        /**
         * Starts a custom visual countdown timer.
         * @param {number} duration - The total duration the timer should count down from.
         * @param {number} [startTime=0] - The time in seconds that has already elapsed (used for resuming).
         */
        function startCountdown(duration, startTime = 0) {
            stopCountdown();
            currentTimerDuration = duration; 
            
            customTimerDisplay.classList.remove('hidden');
            
            let remainingTime = currentTimerDuration - startTime; 

            // Set initial display
            currentTimeElement.textContent = remainingTime.toFixed(2);
            
            const realStartTime = performance.now() - (startTime * 1000);

            timerInterval = setInterval(() => {
                const elapsedTime = (performance.now() - realStartTime) / 1000;
                remainingTime = currentTimerDuration - elapsedTime; 

                if (remainingTime <= 0) {
                    stopCountdown();
                    currentTimeElement.textContent = '0.00';
                    return; 
                } 
                currentTimeElement.textContent = remainingTime.toFixed(2);
            }, 50); 
        }

        // Add a listener to stop the timer and reset mode when the audio ends naturally
        audioPlayer.onended = () => {
            stopCountdown();
            currentPlayingMode = null;
            updateButtonLabels(null);
            audioPlayer.playbackRate = 1.0; // Reset rate after playback
            ttsPacingNote.textContent = 'Pacing: Normal (1.00x)';
            // Hide the custom timer once playback is complete
            customTimerDisplay.classList.add('hidden');
        };

        // Add a listener to handle play/pause synchronization
        audioPlayer.onplay = () => {
             // Stop any previous interval and restart it from the current time
             const actualDuration = audioPlayer.duration / audioPlayer.playbackRate;
             startCountdown(actualDuration, audioPlayer.currentTime / audioPlayer.playbackRate);
             
             if (currentPlayingMode === 'normal') {
                 updateButtonLabels('normal-playing');
             } else if (currentPlayingMode === 'conformed') {
                 updateButtonLabels('conformed-playing');
             } else if (currentPlayingMode === 'custom') {
                 updateButtonLabels('custom-playing');
             }
        };

        audioPlayer.onpause = () => {
            stopCountdown();
            if (currentPlayingMode === 'normal') {
                updateButtonLabels('normal-paused');
            } else if (currentPlayingMode === 'conformed') {
                updateButtonLabels('conformed-paused');
            } else if (currentPlayingMode === 'custom') {
                updateButtonLabels('custom-paused');
            }
        };
        
        /**
         * Updates the text and state of the play buttons based on the current playback status.
         * @param {string|null} mode - Current state: 'normal', 'conformed', 'custom', 'normal-playing', etc., or null to reset.
         */
        function updateButtonLabels(mode) {
            const formatTime = (time) => (time !== null && time !== undefined ? time.toFixed(2) + 's' : '---');

            const normalDuration = timeCP;
            const conformedDuration = targetTime;
            const customRate = parseFloat(dynamicRateInput.value);
            const customDuration = timeCP / customRate;
            
            // 1. Reset all buttons to default appearance/text
            playNormalButton.textContent = `Play Normal (${formatTime(normalDuration)})`;
            playConformedButton.textContent = `Play Conformed (${formatTime(conformedDuration)})`;
            playCustomButton.textContent = `Play at Custom Rate`;

            // 2. Handle active/paused/playing states
            if (mode === 'normal-playing') {
                playNormalButton.textContent = 'PAUSE (Normal)';
                playNormalButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                playNormalButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else if (mode === 'normal-paused') {
                playNormalButton.textContent = 'RESUME (Normal)';
                playNormalButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
                playNormalButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else {
                playNormalButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                playNormalButton.classList.add('bg-gray-500', 'hover:bg-gray-600');
            }

            if (mode === 'conformed-playing') {
                playConformedButton.textContent = 'PAUSE (Conformed)';
                playConformedButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                playConformedButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else if (mode === 'conformed-paused') {
                playConformedButton.textContent = 'RESUME (Conformed)';
                playConformedButton.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                playConformedButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else {
                playConformedButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                playConformedButton.classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }

            if (mode === 'custom-playing') {
                playCustomButton.textContent = `PAUSE (${formatTime(customDuration)})`;
                playCustomButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                playCustomButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else if (mode === 'custom-paused') {
                playCustomButton.textContent = `RESUME (${formatTime(customDuration)})`;
                playCustomButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                playCustomButton.classList.add('bg-orange-500', 'hover:bg-orange-600');
            } else {
                playCustomButton.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                playCustomButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }

            // Ensure only the currently playing/paused mode is active/resumable
            const playButtons = [playNormalButton, playConformedButton, playCustomButton];
            
            playButtons.forEach(btn => {
                if (mode && !mode.includes('playing') && !mode.includes('paused')) {
                     // If we are playing, disable others, otherwise enable all if audio is ready
                } else if (mode && mode.includes('playing')) {
                    if (btn !== document.getElementById(`play${mode.split('-')[0].charAt(0).toUpperCase() + mode.split('-')[0].slice(1)}Button`)) {
                        btn.disabled = true;
                    }
                } else if (mode && mode.includes('paused')) {
                    if (btn !== document.getElementById(`play${mode.split('-')[0].charAt(0).toUpperCase() + mode.split('-')[0].slice(1)}Button`)) {
                        btn.disabled = true;
                    } else {
                        btn.disabled = false;
                    }
                } else if (timeCP > 0) {
                    btn.disabled = false; // Enable all if audio is loaded
                } else {
                    btn.disabled = true; // Disable all if audio is not loaded
                }
            });

            // Ensure custom button is only enabled if the dynamic control is visible
            if (dynamicSpeedControl.classList.contains('hidden')) {
                playCustomButton.disabled = true;
            }
        }


        // --- Core Logic: Calculation & TTS ---

        /**
         * Calculates the estimated spoken time (timeCP) and displays the results.
         */
        function calculateTiming() {
            // 1. Validate Input
            const dialogue = inputElement.value;
            const wordCount = countWords(dialogue);
            
            if (wordCount === 0 || wordCount > MAX_WORDS) {
                showModal('Please enter a dialogue between 1 and 200 words.');
                return;
            }
            
            // 2. Calculate Comfortable Pacing Time (Estimation)
            // Time (seconds) = (Word Count / WPM) * 60 seconds
            const spokenDurationEstimate = (wordCount / CP_WPM) * 60;
            const targetDuration = parseFloat(targetTimeInput.value);
            
            // Update global state and UI
            targetTime = targetDuration; // Update global target
            
            // 3. Determine required rate (This is purely informative before TTS loads)
            requiredPlaybackRate = spokenDurationEstimate / targetDuration;
            
            // 4. Display Results (Status Light)
            const diff = spokenDurationEstimate - targetDuration;
            const absDiff = Math.abs(diff);
            
            let statusClass;
            let message;
            
            if (spokenDurationEstimate <= targetDuration) {
                // Spoken time is less than or equal to target (Green status)
                statusClass = 'bg-green-500';
                message = `Pacing is comfortable. Estimated time: ${spokenDurationEstimate.toFixed(2)}s`;
            } else if (absDiff / targetDuration <= ACCEPTABLE_VARIANCE) {
                // Spoken time is up to 20% over target (Yellow status)
                statusClass = 'bg-yellow-500';
                message = `Pacing may be slightly rushed. Estimated time: ${spokenDurationEstimate.toFixed(2)}s`;
            } else {
                // Spoken time is significantly over target (Red status)
                statusClass = 'bg-red-500';
                message = `Pacing is too fast! Estimated time: ${spokenDurationEstimate.toFixed(2)}s`;
            }
            
            // Update UI elements
            statusLight.className = `w-6 h-6 rounded-full shadow-lg transition-colors duration-300 mt-1 ${statusClass}`;
            resultMessage.textContent = message;
            finalWordCount.textContent = wordCount;
            pacingInfo.textContent = `To meet the ${targetDuration.toFixed(2)}s target, the dialogue must be spoken at ${(requiredPlaybackRate * 100).toFixed(0)}% speed.`;
            
            // Show result section
            resultsBox.classList.remove('hidden');

            // Set dynamic control initial value to the required rate
            dynamicRateInput.value = requiredPlaybackRate.toFixed(2);
            updateDynamicRateDisplay(requiredPlaybackRate.toFixed(2));
            
            // Enable preparation controls
            prepareButton.disabled = false;
        }

        /**
         * Converts a Base64 string to an ArrayBuffer.
         * @param {string} base64 - Base64 data string.
         * @returns {ArrayBuffer}
         */
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        /**
         * Writes a string to a DataView at a specified offset.
         * @param {DataView} view
         * @param {number} offset
         * @param {string} string
         */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        /**
         * Converts signed 16-bit PCM audio data to a WAV format Blob.
         * @param {Int16Array} pcm16 - Raw PCM data.
         * @param {number} sampleRate - Sample rate (e.g., 24000).
         * @returns {Blob} The WAV audio blob.
         */
        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit PCM
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcm16.byteLength;
            const totalLength = 44 + dataLength; // 44 bytes for the WAV header

            const buffer = new ArrayBuffer(totalLength);
            const view = new DataView(buffer);

            let offset = 0;

            // 1. RIFF chunk
            writeString(view, offset, 'RIFF'); offset += 4;
            view.setUint32(offset, totalLength - 8, true); offset += 4; // ChunkSize
            writeString(view, offset, 'WAVE'); offset += 4;

            // 2. FMT chunk
            writeString(view, offset, 'fmt '); offset += 4;
            view.setUint32(offset, 16, true); offset += 4; // Subchunk1Size (16 for PCM)
            view.setUint16(offset, 1, true); offset += 2; // AudioFormat (1 for PCM)
            view.setUint16(offset, numChannels, true); offset += 2; // NumChannels
            view.setUint32(offset, sampleRate, true); offset += 4; // SampleRate
            view.setUint32(offset, byteRate, true); offset += 4; // ByteRate
            view.setUint16(offset, blockAlign, true); offset += 2; // BlockAlign
            view.setUint16(offset, bytesPerSample * 8, true); offset += 2; // BitsPerSample

            // 3. DATA chunk
            writeString(view, offset, 'data'); offset += 4;
            view.setUint32(offset, dataLength, true); offset += 4; // Subchunk2Size

            // Write the PCM data
            const pcmBytes = new Uint8Array(pcm16.buffer);
            for (let i = 0; i < dataLength; i++) {
                view.setUint8(offset + i, pcmBytes[i]);
            }

            return new Blob([view], { type: 'audio/wav' });
        }


        /**
         * Makes the TTS API call with exponential backoff for retries.
         * @param {string} text - The dialogue text.
         * @param {string} voice - The selected voice name.
         * @param {number} retryCount - Current retry attempt.
         * @returns {Promise<object>} The JSON response from the API.
         */
        async function makeApiCall(text, voice, retryCount = 0) {
            const payload = {
                contents: [{
                    parts: [{ text: text }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voice }
                        }
                    }
                },
            };

            try {
                const response = await fetch(API_FULL_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.status === 429 && retryCount < MAX_RETRIES) {
                    const delay = Math.pow(2, retryCount) * 1000;
                    console.warn(`Rate limit exceeded. Retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return makeApiCall(text, voice, retryCount + 1);
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                
                // Validate response structure
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                if (!part || !part.inlineData?.data || !part.inlineData?.mimeType) {
                    throw new Error("Invalid API response structure or missing audio data.");
                }

                return result;

            } catch (error) {
                console.error("TTS API Call failed:", error);
                throw new Error(`Failed to generate audio: ${error.message}. Please check your input.`);
            }
        }

        /**
         * Handles the entire process of calling the TTS API, converting the audio,
         * and setting up the audio player.
         */
        async function prepareAudio() {
            clearResults(); // Ensure a fresh start
            const dialogue = inputElement.value;
            const voice = voiceSelect.value;
            
            if (countWords(dialogue) === 0) {
                showModal("Please enter some dialogue to prepare the audio.");
                return;
            }

            // UI feedback for loading
            prepareButton.disabled = true;
            submitButton.disabled = true;
            voiceSelect.disabled = true;
            prepareText.textContent = 'Generating...';
            prepareSpinner.style.display = 'inline-block';
            
            // Hide play buttons while generating
            playButtonContainer.classList.add('hidden');
            dynamicSpeedControl.classList.add('hidden');

            try {
                const result = await makeApiCall(dialogue, voice);

                const part = result.candidates[0].content.parts[0];
                const audioData = part.inlineData.data;
                const mimeType = part.inlineData.mimeType; // Should be audio/L16;rate=...

                if (!mimeType.includes('audio/L16')) {
                    throw new Error("The API returned an unexpected audio format.");
                }
                
                // Extract sample rate from mimeType (e.g., audio/L16;rate=24000)
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                
                // 1. Convert Base64 (L16 data) to ArrayBuffer
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);

                // 2. Convert PCM to WAV Blob
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);

                // 3. Set Audio Player source
                audioPlayer.src = audioUrl;
                audioPlayer.classList.remove('hidden');

                // Wait for audio metadata to load to get the actual duration
                await new Promise(resolve => {
                    audioPlayer.onloadedmetadata = () => {
                        timeCP = audioPlayer.duration; // This is the actual 1.0x duration
                        resolve();
                    };
                });
                
                // 4. Re-calculate the actual required rate and update results
                const targetDuration = parseFloat(targetTimeInput.value);
                requiredPlaybackRate = timeCP / targetDuration;
                
                // Update results display with actual duration
                actualDurationSpan.textContent = timeCP.toFixed(2) + 's';
                actualDurationDisplay.classList.remove('hidden');

                // Update the status message to use the measured duration
                resultMessage.textContent = resultMessage.textContent.replace('Estimated time:', 'Measured time:');
                pacingInfo.textContent = `To meet the ${targetDuration.toFixed(2)}s target, the dialogue must be spoken at ${(requiredPlaybackRate * 100).toFixed(0)}% speed.`;

                // 5. Update Playback Controls
                playNormalButton.textContent = `Play Normal (${timeCP.toFixed(2)}s)`;
                playConformedButton.textContent = `Play Conformed (${targetDuration.toFixed(2)}s)`;

                playNormalButton.disabled = false;
                playConformedButton.disabled = false;
                
                playButtonContainer.classList.remove('hidden');
                dynamicSpeedControl.classList.remove('hidden');
                playCustomButton.disabled = false;
                
                // Also update the dynamic speed display with the new timeCP
                updateDynamicRateDisplay(dynamicRateInput.value);

            } catch (error) {
                showModal(error.message);
                console.error(error);
                clearResults(); // Ensure all buttons are reset
            } finally {
                // UI feedback reset
                prepareText.textContent = 'Audio Ready!';
                prepareSpinner.style.display = 'none';
                submitButton.disabled = false;
                prepareButton.disabled = true; // Audio is ready, disable prepare button
                voiceSelect.disabled = true; // Keep voice locked until clearResults()
            }
        }


        // --- Playback Functions ---
        
        /**
         * Generic function to start/pause audio playback.
         * @param {number} rate - The playback rate (1.0 for normal, >1.0 for faster, etc.).
         * @param {number} duration - The total perceived duration (for the timer).
         * @param {string} mode - 'normal', 'conformed', or 'custom'.
         */
        function playAudio(rate, duration, mode) {
            // Check if audio is loaded
            if (timeCP === 0 || audioPlayer.src === "") {
                showModal("Audio has not been prepared yet. Click 'Calculate' and then 'Prepare Audio'.");
                return;
            }

            // If we are currently in the same mode and playing, pause it.
            if (currentPlayingMode === mode && !audioPlayer.paused) {
                audioPlayer.pause();
                return;
            }
            
            // If we are in the same mode and paused, resume.
            if (currentPlayingMode === mode && audioPlayer.paused) {
                audioPlayer.play();
                return;
            }
            
            // If we are switching modes, stop and reset the audio
            if (currentPlayingMode !== null && currentPlayingMode !== mode) {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
            }
            
            // Set up new playback
            currentPlayingMode = mode;
            audioPlayer.playbackRate = rate;
            currentTimerDuration = duration;
            ttsPacingNote.textContent = `Pacing: ${mode} (${rate.toFixed(2)}x)`;

            // Start playing and trigger onplay listener for timer/button updates
            audioPlayer.play();
            updateButtonLabels(mode + '-playing');
        }

        function playNormalAudio() {
            playAudio(1.0, timeCP, 'normal');
        }

        function playConformedAudio() {
            // Ensure rate is not zero or negative
            const rate = requiredPlaybackRate > 0 ? requiredPlaybackRate : 1.0;
            playAudio(rate, targetTime, 'conformed');
        }

        function playCustomRateAudio() {
            const rate = parseFloat(dynamicRateInput.value);
            const duration = timeCP / rate;
            // Ensure rate is within safe bounds (0.5 to 2.0 per slider, but check just in case)
            if (rate < 0.5 || rate > 2.0) {
                 showModal("Custom rate is outside the safe range (0.5x to 2.0x). Please adjust the slider.");
                 return;
            }
            playAudio(rate, duration, 'custom');
        }

        /**
         * Updates the dynamic rate display and calculates the resulting duration.
         * This also automatically updates the playCustomButton label.
         * @param {string} rateValue - The current value of the dynamic rate slider.
         */
        function updateDynamicRateDisplay(rateValue) {
            const rate = parseFloat(rateValue);
            currentDynamicRate.textContent = rate.toFixed(2);
            
            // Only calculate duration if timeCP (actual audio duration) is known
            let duration;
            if (timeCP > 0) {
                duration = timeCP / rate;
                currentDynamicDuration.textContent = duration.toFixed(2);
                playCustomButton.textContent = `Play at Custom Rate (${duration.toFixed(2)}s)`;
            } else {
                // Fallback using WPM estimation if prepareAudio hasn't run
                const dialogue = inputElement.value;
                const wordCount = countWords(dialogue);
                const spokenDurationEstimate = (wordCount / CP_WPM) * 60;
                duration = spokenDurationEstimate / rate;
                currentDynamicDuration.textContent = duration.toFixed(2);
                playCustomButton.textContent = `Play at Custom Rate (${duration.toFixed(2)}s)`;
            }
        }
        
        // --- Initialization ---

        window.onload = function() {
            // Initial check to disable/enable submit button
            updateWordCount(inputElement);
            // Initial setting of target time display
            updateTargetTimeDisplay(targetTimeInput.value);
            // Initial setup for the dynamic rate display
            updateDynamicRateDisplay(dynamicRateInput.value);
            
            // Ensure the submit button is disabled initially if no text is present
            if (countWords(inputElement.value) === 0) {
                 submitButton.disabled = true;
            }
        };

    </script>
</body>
</html>
